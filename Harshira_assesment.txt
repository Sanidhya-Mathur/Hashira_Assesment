#include <iostream>
#include <vector>
#include <string>
#include <cmath>
#include <map>
#include <fstream>
#include <iomanip>

// Convert string in base 'base' to decimal
long long from_base(const std::string& s, int base) {
    long long result = 0;
    for (char c : s) {
        int digit;
        if (c >= '0' && c <= '9') {
            digit = c - '0';
        } else if (c >= 'a' && c <= 'z') {
            digit = c - 'a' + 10;
        } else if (c >= 'A' && c <= 'Z') {
            digit = c - 'A' + 10;
        }
        result = result * base + digit;
    }
    return result;
}

// Gaussian elimination for system of equations with improved numerical stability
std::vector<long double> gauss(std::vector<std::vector<long double>> mat, std::vector<long double> y) {
    int n = y.size();
    
    // Forward elimination with partial pivoting
    for (int i = 0; i < n; ++i) {
        // Find the row with largest pivot
        int max_row = i;
        for (int k = i + 1; k < n; ++k) {
            if (fabs(mat[k][i]) > fabs(mat[max_row][i])) {
                max_row = k;
            }
        }
        
        // Swap rows if needed
        if (max_row != i) {
            std::swap(mat[i], mat[max_row]);
            std::swap(y[i], y[max_row]);
        }
        
        // Eliminate column
        for (int k = i + 1; k < n; ++k) {
            if (fabs(mat[i][i]) > 1e-15) {  // Avoid division by very small numbers
                long double factor = mat[k][i] / mat[i][i];
                for (int j = i; j < n; ++j) {
                    mat[k][j] -= factor * mat[i][j];
                }
                y[k] -= factor * y[i];
            }
        }
    }
    
    // Back substitution
    std::vector<long double> x(n);
    for (int i = n - 1; i >= 0; --i) {
        x[i] = y[i];
        for (int j = i + 1; j < n; ++j) {
            x[i] -= mat[i][j] * x[j];
        }
        x[i] /= mat[i][i];
    }
    
    return x;
}

// Simple JSON parser for this specific format
std::map<std::string, std::string> parse_json(const std::string& json_str) {
    std::map<std::string, std::string> result;
    
    // This is a simple parser for the specific JSON format given
    // In a real application, you'd use a proper JSON library
    
    size_t pos = 0;
    while ((pos = json_str.find("\"", pos)) != std::string::npos) {
        size_t key_start = pos + 1;
        size_t key_end = json_str.find("\"", key_start);
        if (key_end == std::string::npos) break;
        
        std::string key = json_str.substr(key_start, key_end - key_start);
        
        // Skip to the value
        pos = json_str.find("\"", key_end + 1);
        if (pos == std::string::npos) break;
        
        size_t value_start = pos + 1;
        size_t value_end = json_str.find("\"", value_start);
        if (value_end == std::string::npos) break;
        
        std::string value = json_str.substr(value_start, value_end - value_start);
        result[key] = value;
        
        pos = value_end + 1;
    }
    
    return result;
}

int main() {
    // Test Case 1
    std::cout << "=== TEST CASE 1 ===" << std::endl;
    
    // Manually input the first test case data
    std::vector<int> x1 = {1, 2, 3, 6};
    std::vector<long long> y1;
    
    y1.push_back(from_base("4", 10));      // "1": base 10, value "4" -> 4
    y1.push_back(from_base("111", 2));     // "2": base 2, value "111" -> 7
    y1.push_back(from_base("12", 10));     // "3": base 10, value "12" -> 12
    y1.push_back(from_base("213", 4));     // "6": base 4, value "213" -> 39
    
    int k1 = 3;  // minimum points needed
    
    // Build Vandermonde matrix for first k points
    std::vector<std::vector<long double>> V1(k1, std::vector<long double>(k1));
    for (int i = 0; i < k1; ++i) {
        long double x_power = 1.0L;
        for (int j = 0; j < k1; ++j) {
            V1[i][j] = x_power;
            x_power *= x1[i];
        }
    }
    
    std::vector<long double> y1_ld(k1);
    for (int i = 0; i < k1; ++i) {
        y1_ld[i] = static_cast<long double>(y1[i]);
    }
    
    std::vector<long double> coeffs1 = gauss(V1, y1_ld);
    long long secret1 = static_cast<long long>(round(coeffs1[0]));
    
    std::cout << "Secret (constant term): " << secret1 << std::endl;
    
    // Test Case 2
    std::cout << "\n=== TEST CASE 2 ===" << std::endl;
    
    std::vector<int> x2 = {1, 2, 3, 4, 5, 6, 7};  // First 7 x values
    std::vector<long long> y2;
    
    y2.push_back(from_base("13444211440455345511", 6));    // "1"
    y2.push_back(from_base("aed7015a346d635", 15));        // "2"
    y2.push_back(from_base("6aeeb69631c227c", 15));        // "3"
    y2.push_back(from_base("e1b5e05623d881f", 16));        // "4"
    y2.push_back(from_base("316034514573652620673", 8));   // "5"
    y2.push_back(from_base("2122212201122002221120200210011020220200", 3));  // "6"
    y2.push_back(from_base("20120221122211000100210021102001201112121", 3)); // "7"
    
    int k2 = 7;  // minimum points needed
    
    // Build Vandermonde matrix
    std::vector<std::vector<long double>> V2(k2, std::vector<long double>(k2));
    for (int i = 0; i < k2; ++i) {
        long double x_power = 1.0L;
        for (int j = 0; j < k2; ++j) {
            V2[i][j] = x_power;
            x_power *= x2[i];
        }
    }
    
    std::vector<long double> y2_ld(k2);
    for (int i = 0; i < k2; ++i) {
        y2_ld[i] = static_cast<long double>(y2[i]);
    }
    
    std::vector<long double> coeffs2 = gauss(V2, y2_ld);
    long long secret2 = static_cast<long long>(round(coeffs2[0]));
    
    std::cout << "Secret (constant term): " << secret2 << std::endl;
    
    // Print converted y values for verification
    std::cout << "\nConverted y values for Test Case 2:" << std::endl;
    for (int i = 0; i < k2; ++i) {
        std::cout << "y[" << (i+1) << "] = " << y2[i] << std::endl;
    }
    
    return 0;
}



